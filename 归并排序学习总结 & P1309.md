# 归并排序学习总结 & P1309



## 背景

之所以突然说到归并排序，是因为P1309这道题要用到... 使用快排居然还是超时. 没想到题目需要用到归并排序来做才行. 为什么? 后面题目会讲到 xD   那么回到归并排序. 归并排序在好久好久以前写过, 印象中好像是作业要求的... 那时候随便搜了下相关的资料写完交上去就完事了.  所以对归并排序的印象大概只有Divide and Conquer. 但是具体要怎么写就很模糊了.  通过这道题目算是让我明白, 就靠一个快排还是不够用的. 某些特殊场合还是需要归并来才行. 于是就借此机会好好弄懂下归并排序..



## 归并排序



### 归并排序是怎么进行跑的?

首先我到了GeeksforGeeks上找到了merge sort的[相关教程](https://www.geeksforgeeks.org/merge-sort/).  归并排序的代码是按这么个顺序执行的.

```cpp
MergeSort(arr[], begin, end)  arr数组存放序列 l代表开始下标 r代表结束下标

如果 end比begin 大 // 意思就是当这个范围的元素个数大于1个
	1. 找出这个范围(begin到end)的中点
		mid = (begin + end) / 2;
	2. 对左半部分和右半部进行递归
		MergeSort(arr,begin,mid);
		MergeSort(arr,mid + 1,end);
	3. 把左边部分和右边部分归并
		Merge(arr,begin,mid,end); 
```



简单的说, 就是把一个序列不停的拆分<font color="red">*(直到只剩下一个 没的再拆分了)*</font>成左右两部分(取中)，然后把两部分合起来. 但是要知道的是，之所以拆成两半 然后合并起来就会变成有序. 是因为合并是一个排序的操作. 也就是说 合并使得序列有序. 那么归并排序的核心就是在合并这里了.  拿初始序列[38,27,43,3,9,82,10]作为例子. **假设升序排序 也就是从小到大**



第一次 划分成 [38,27,43,3] 和 [9,82,10]. 然后先对左边部分递归, 变成[38,27],[43,3] 继续对左边分解 变成[38],[27].. 此时被拆分成一个元素了 已经不能再分了. 因此不能继续递归，那么进行合并操作..  由于是要从小到大排, 那么比较一下这两个元素 38比27大 那么应该要互换位置. 并且把这两个元素组合成新的序列才行(因为已经排好了嘛) 那么就变成[27,38]. 返回 来到序列[43,3]这里. 同样道理，通过拆分 然后合并的操作后 变成[3,43].

继续返回，就轮到了[27,38] 和 [3,43] 进行合并了. 很容易得出最后变成[3,27,38,43]. 接下来就是对[9,82,10] 这个序列进行同样的操作 得到[2,8,9,10]. 最后跟[3,27,38,43]合并成[2,3,8,9,10,27,38,43]. 运算的步骤如图所示.

![](https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png) 





### 原理总结一下

可以发现归并排序就是把整个序列一直拆分左右直到剩下一个的时候. 再跟之前拆分的元素合并起来. 由于递归的性质... 可以发现合并的时候, 要合并的两方(也就是两个序列[当然最开始的时候只有一个元素]) 是有序的. 并且再通过判断大小排序. 合并出来的新序列也是有序的... 因此递归回来以后最后一步的合并 两边(最开始的那两大半)合并起来后是有序的 也就是整个序列都变的有序了..





### 归并排序的实现

既然核心是在合并上，那么就看看合并的操作该怎么处理比较好. 继续拿上面的作为例子.. 回到对左半部分的拆分. 拆分到[38],[27]的时候就不再继续拆了. 进行合并 也就是排序. 只有两个元素的时候很容易排序 只需要直接比较两者即可.. 那么如果大于2个的时候呢.. 算法继续进行下去 来到[27,38] 和 [3,43] 进行合并的时候.  这时候就不能直接排序了. 即使通过不停的比较 例如从两边的第一个元素开始, 3比27小 那么 3是整个序列的第一个. 那么这时候得把3放到第一个位置 但这样就会覆盖掉27..  ~~啊？你说把27换到3的位置 那么如果[3,43]这个序列是[3,26]呢 如果交换以后就变成[27,26]了 那接下来该怎么排呢...~~

所以这时候就需要定义一个辅助数组来保存排序的结果.. 只需要不停的两边比较 3比左边的27小 那么把3放进一个缓存数组的第一位, 因为取出了右边序列的第一个 那么下一轮比较就需要拿"它"的下一个数 也就是43  跟左边的第一个数比较 以此类推（关于这个序列的排序顺序是这样的）

27 3  	把3放进数组
27 43	把27放进数组
38 43	把38放进数组
43		因为另外一边已经放完了 只剩下右边了 全放进去



**所以关键是辅助数组** 



#### 写法

第一种的话 网上大多数都是直接开一个temp[n]数组 （n为整个序列长度 以上例子n为7） 直接把排序的结果放在相对应的位置上，最后再赋值回原数组（因为是知道begin,end,mid 所以直接放到对应的位置上 不难理解） 这种写法用起来方便 但是在归并过程的空间使用比较大 （只是过程  最终的话 第二个写法也还是要开长度为n的辅助数组）

```cpp
void Merge(int arr[],int begin,int mid,int end)
{
    int temp[n] = {};
    
    int begin1 = begin , end1 = mid; // 左部分的下标范围
    int begin2 = mid + 1 , end2 = end; // 右部分的下标范围
    int k = begin;

    while(begin1 <= end1 && begin2 <= end2) // 循环进行到有一边被排序完
    {
        // 从小到大排 如果哪边的元素更小 那就放到辅助数组上 并把下标向前移动
        temp[k ++] = arr[begin1] > arr[begin2] ? arr[begin2 ++] : arr[begin1 ++];
    }
    
    // 因为上面循环的条件 有一边被排完以后就会跳出来 另外一边肯定还会有剩的
	// 并且剩下的那边因为是有序的 所以直接一个个赋值过去就行
    while(begin1 <= end1) 
    {
        temp[k ++] = arr[begin1 ++];
    }
    while(begin2 <= end2)
    {
        temp[k ++] = arr[begin2 ++];
    }
	
    // 把排序的结果赋值到原数组上
    for(int i = begin;i <= end;i ++)
    {
        arr[i] = temp[i];
    }
}
```



第二种 拿上面[27,38] 和 [3,43]合并作为例子 很明显并不需要开长度为n(也就是7)的辅助数组 因为这里才4个元素. 那么只需要开两个对应着左右序列长度的数组 也就是temp1[n1] , temp2[n2];  在这里会是为temp1[2] , temp2[2];  首先先把序列赋值到两个数组上.. 然后通过这两个数组不停的比较，得出的结果直接赋值到原数组上.. 

```cpp
void Merge(int arr[],int begin,int mid,int end)
{
    // 计算出两边序列的长度
    int n1 = mid - begin , n2 = end - (mid + 1);
    // 之所以+1 是因为下标是从0开始的 举个例子 假如begin = 0,mid = 4;
    //mid - begin = 4 然而事实上是有5个元素的
    int temp1[n1 + 1] = {};  
    int temp2[n2 + 1] = {};

    for(int i = 0;i <= n1;i ++) // 赋值
    {
        temp1[i] = arr[i + begin];
    }
    for(int i = 0;i <= n2;i ++)
    {
        temp2[i] = arr[i + mid + 1];
    }
    
    int i = 0,j = 0,k = begin;
    // 同第一种方法
    while(i <= n1 && j <= n2)
    {
        arr[k ++] = temp1[i] > temp2[j] ? temp2[j ++] : temp1[i ++];
    }
    // 同第一种方法
    while(i <= n1)
    {
        arr[k ++] = temp1[i ++];
    }
    while(j <= n2)
    {
        arr[k ++] = temp2[j ++];
    }
}
```



### 归并排序总结一下

对于归并排序，简单的说大概就是.. 把序列不停的拆分成单个元素. 然后再按平分的过程 归并回去(这句话的意思就是 [4,1,2,3] 分成 [4,1],[2,3] 分成[4],[1] **|** [2],[3] 然后合成回[1,4], [2,3]  继续[1,2,3,4] )... **并且有一个很重要的特点就是 合并的时候 左右两部分都是有序的**  这一性质也许会在很多地方上用上 从而使得归并排序能够比快速排序快 (接下来的一道题就是这种情况). 因此利用好该性质 某些情况下归并排序并不输快速排序... 





## P1309 瑞士轮



### 题目描述

2×N 名编号为1−2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第 1 名和第 2 名、第 3 名和第 4 名、……、第 2K - 1名和第 2K名、…… 、第 2N - 1名和第 2N 名，各进行一场比赛。每场比赛胜者得 1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第Q的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。



### 输入输出格式



#### 输入格式

第一行是三个正整数 N,R,Q每两个数之间用一个空格隔开，表示有2×N名选手、R 轮比赛，以及我们关心的名次 Q 。

第二行是2×N 个非负整数$s_1,s_2,…,s_{2N}$，每两个数之间用一个空格隔开，其中$ s_i $表示编号为 i 的选手的初始分数。 第三行是2×N 个正整数$w_1,w_2,…,w_{2N}$，每两个数之间用一个空格隔开，其中$w_i$ 表示编号为 i的选手的实力值。$w_1 , w_2 , …, w_{2N}$  



#### 输出格式

一个整数，即 RR 轮比赛结束后，排名第$Q$的选手的编号。



### 输入输出样例

#### 输入样例#1

```
2 4 2 
7 6 6 7 
10 5 20 15 

```

#### 输出样例#1

```
1
```



### 数据范围

对于 $30\%$的数据，$ 1 ≤ N ≤ 100$

对于 $50\%$ 的数据，$1 ≤ N ≤ 10,000$

对于 $100\%$的数据，$1 ≤ N ≤ 100,000$ , $1 ≤ R ≤ 50$ ,$1 ≤ Q ≤ 2N$ ,$0 ≤ s_1, s_2, …, s_{2N}≤10^8$,$1 ≤w_1, w_2 , …, w_{2N}≤ 10^8$ 



### 题目思路

题目的意思还是很容易搞懂的.. 每个选手一开始都会有一个能力值 该值是唯一且不会变 选手之间通过能力值的比较来决出胜负. 每个选手会有一个分数值 并且比赛开始前会有一个初始分数. 比赛前要根据选手的积分降序排序. 经过多轮的比赛后 （**并且每轮比赛后要重新排序**），输出指定名次的选手的编号（编号是在数据输入的时候定好的 例如第一个输入的选手就是1）



弄懂了以后第一想法大概就是直接模拟 **快排 然后遍历所有选手进行比赛 比赛结束后快排**  然而经过提交以后发现会tle（其实自己算算复杂度就懂了） 复杂度为O（R *（2N\*Log2N + 2N）） 在最大的情况下是必定超时的. 也说明了如果直接排序是行不通的， 毕竟快排都已经t的不行了



这道题就得用归并排序来解决了...  但是也并不是完全用归并排序. 这句话的意思 并不是直接用归并排序代替掉快排.. 而是要利用归并排序的一个特点 **合并的时候两部分都是有序的** 这个特点进行排序. 



因为每次比赛前都会排序好 积分越多的越在前面. 那么就说明了 在整个序列中 每个赢的人的积分都是降序的  而输的人也是这样

```
1  2  3 4 5 6
13 10 9 7 5 3  // 就不写能力值了 假设1赢2 4赢3 6赢5

//那么依次把赢的人 1、4、6拿出来 那么这个序列的积分也是有序的不是吗
//输的人 2、3、5 他们的积分也都是有序的
```

既然赢的人和输的人都能组成一个有序的序列 那么就拿两个数组把这些人存放起来 通过归并排序的那个特点进行排序 那么把整个序列排序好只需要O（2N）的复杂度 （只需要遍历每个选手就行了） 而总体的复杂度是O（R * （2N + 2N））相比使用快排的复杂度就降低很多了.





### 题目代码

```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
int read()
{
    char ch = getchar();
    int f = 1;
    int x = 0;
    while(ch < '0' || ch > '9'){if(ch == '-')f = 0;ch = getchar();}
    while(ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return f?x:x*-1; 
}
struct node
{
    int i,count,p;
    bool operator < (const node a)const
    {
        if(count > a.count)
        {
            return true;
        }
        if(count < a.count)
        {
            return false;
        }
        return i < a.i;
    }
};
node ans[200000];
node win[100000];
node lose[100000];
void merge(int w,int l)
{
    int i = 0,j = 0,k = 0;
    
    while(i < w && j < l)
    {
        if(win[i].count == lose[j].count)
        {
            if(win[i].i < lose[j].i)
            {
                ans[k] = win[i ++];
            }
            else
            {
                ans[k] = lose[j ++];
            }
        }
        else if(win[i].count > lose[j].count)
        {
            ans[k] = win[i ++];
        }
        else
        {
            ans[k] = lose[j ++];
        }
        k ++;
    }

    while(i < w)
    {
        ans[k ++] = win[i ++];
    }
    while(j < l)
    {
        ans[k ++] = lose[j ++];
    }
}
int main()
{
    int n = read(),r = read(),q = read();
    int t = 2 * n;
    for(int i = 0;i < t;i ++)
    {
        ans[i].i = i + 1;
        ans[i].count = read();
    }
    for(int i = 0;i < t;i ++)
    {
        ans[i].p = read();
    }

    sort(ans,ans + t);

    for(int i = 0;i < r;i ++)
    {
        int w = 0,l = 0;
        for(int j = 0;j < t - 1;j += 2)
        {
            if(ans[j].p > ans[j + 1].p)
            {
                win[w] = ans[j];
                win[w ++].count ++;
                lose[l ++] = ans[j + 1];
            }    
            else
            {
                win[w] = ans[j + 1];
                win[w ++].count ++;
                lose[l ++] = ans[j];
            }
        }
        merge(w,l);
    }
    printf("%d",ans[q - 1].i);

    return 0;
}
```

